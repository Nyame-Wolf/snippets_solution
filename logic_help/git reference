to have a single character prompt
 SAVE=$PS1
 PS1=$ or PS1="$ "- forcing  a space making it more readable
To restore your original prompt, just call up the variable you stored:
 PS1=$SAVE

to check if you have an existing git
which git

to configure users
git config --global user.name "<name>"
git config --global user.email "<email>"

to confirm values of git config
cat or less  ~/.gitconfig
git config --list

to change username and email
git config --global --replace-all user.name "Your New Name"
git config --global --replace-all user.email "Your new email"
or 
You can use the --unset flag of git config to do this like so:
git config --global --unset user.name
git config --global --unset user.email
If you have more variables for one config you can use:
git config --global --unset-all user.name

to get help from git
git help <verb>
to navigate output of git help pipe output to less
git help | less

To start using git
There are two scenarios:
1.)You have an existing project that you want to start tracking using git.
2.)There is an existing project remotely that you want to begin working on.

Scenario 1( Initialize a Repository From Existing Code)
$ ls- To show you directory in
$ cd <directory name>/

$ ls-la -Lists all files in the directory
$git init directory. Contains everything related to our repository

.gitignore
This are files we don't want other people to see. This may contain personal preferences specific to our machines or os that aren't part of the code.  files you don’t want to commit. These include files containing secret credentials, configuration files that aren’t shared across computers, temporary files, log files
This files we want to be ignored, when collaborating with other users, could easily cause conflicts
We use a .gitignore e.g touch. gitignore
*pyc is a  python examples...is a wildcard can be used to ignore all .pyc file.
----Go back to directory one is working on, open the .gitignore file and add the names of what you want ignored
$git status
Lists what is to be ignored.

to start tracking
$git add -A
the -A option tells Git to add all untracked files,
99% of the time you add files you’ll want to add them all, so this is a good habit to cultivate
-To track one file we use $git add <file>
By the way, the equivalent command git add ., where the dot refers to the current directory, is also common

To see the result of git add -A  run git status again

Untracked/unstaged--->git add == staged
-->git commit == local repository -->git push == Remote Repository
untracked and unstaged are different states, but the distinction is rarely important because git add tracks and stages files at the same time

To stop tracking our project
$rm  -rf .git as is done to remove any directory
$ ls-la - will show you if tracking has stopped.

In git we have a working directory, the staging area and the committed files.
-In the working directory we have untracked and modified files. By running $git status, it lists those.
-Staging area is where we organize what we want to be committed to our repository. It helps us pick and choose what we want committed.
If we have a lot of work spanning several files and want to make several commits from those changes, then we can stage individual files and commit those in small chunks. We are more detailed with our commits.

=>To add all files that are currently untracked  or we have made changes to
We run $git add -A(capital letter A)
Or we can add files individually $git add <file>e.g. $git add .gitignore
->At this point, status of the file has been promoted from untracked to staged., meaning file is ready to be added to the repository 

=>To remove files from staging area:$
$git reset- without options removes everything
$git reset <file>

=>To commit changes:
$git commit -m "<detailed message of what the changes are>"
->after putting changes in the staging area we can make them part of the local repository by committing them.
-m command line option includes a message to indicate the purpose of the commit
Typically, this takes the form of a single line, usually limited to around 72 characters, with an optional longer message if desired 
->The messages should be in present tense using imperative move: 'initialize repo' not 'initializes repo'
->The reason for this convention is that Git models commits as a series of text transformations, and in this context it makes sense to describe what each commit does instead of what it did. Moreover, this usage agrees with the convention followed by the commit messages generated by Git commands themselves (e.g., “merge” rather than “merges” or “merged”). 

$git log - To see about what we have committed
->the commit is identified by a hash which is a unique string of letters and numbers that git uses to label the commit and which lets git retrieve the commits changes.
SHA-refers to the hash because of the name Secure  Hash Algorithms used to generate it

git log -p shows the full diffs represented by each commit while git log shows only the commit messages

$ git diff
It’s often useful to be able to view the changes represented by a potential commit before making it
By default it shows the difference between the last commit and unstaged changes in current project
As with the Unix diff utility, modified sections of code or markup are shown as close to each other as possible so that it’s clear at a glance what changed

git show <SHA> shows diff vs the SHA
$git show fv738e....

->After making changes to an existing file we can use  -a(option for all) which arranges to commit all the changes in currently existing files
$ git  commit -a -m " ......."
... reps messages describing the commits.
**#Note that the -a option includes changes only to files already added to the repository, so when there are new files it’s important to run git add -A
**#(In fact, simply adding the changes is sufficient; running git add -Awould also lead to there being no diff. To see the difference between staged changes and the previous version of the repo, use git diff --staged.)

To combine two steps, of git add -A and git commit -m "..." we can use &&
$ git add -A && git commit -m "..."

we used both the -a and -m options to commit all pending changes while adding a commit message, but in fact the two can be combined as -am

If we make a mistake in our commit message
$git commit --amend -m "an updated commit message"

$git commit --amend --no-edit
This allows you to make amendments to your commit without changing its commit message.

->for remote repository(git-hub, we can avoid typing our username and password by using ssh
using ssh
-:>first check if you have existing key
https://help.github.com/en/articles/checking-for-existing-ssh-keys
$ ls -al ~/.ssh
# Lists the files in your .ssh directory, if they exist
-:>if it doesn't exist we can generate a new one:
$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
flags: -t, type, -b bytes, -C label to create keygen with
This creates a new ssh key, using the provided email as a label.
> Generating public/private rsa key pair.
When you're prompted to "Enter a file in which to save the key," press Enter. This accepts the default file location.
> Enter a file in which to save the key (/home/you/.ssh/id_rsa): [Press enter]
> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again]
-:>Adding your SSH key to the ssh-agent
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_rsa
-:>got to github-settings-sshkey-new key
input title you can remember:
location is ~/.ssh/id_rsa.pub
for macbook -$ pbcopy location
for windows $ clip location
for linux, must install xclip to copy
sudo apt-get install xclip
$xclip -sel clip < ~/.ssh/id_rsa.pub


=>To now push our code in remote repo
$git remote add origin https://github.com/<name>/website.git
$git push -u origin master
#-name reps user name.
Above, first command sets github as the romote origin and then push the the full repository
The -u option to git push sets github as the upstream repository, meaning we are able to download any changes automatically when we run git pull.

-:> After commiting we need to sync all code we have with the remote repo 
To push to the remote repo
$ git push

branching:
One of the most powerful features of Git is its ability to make branches, which are effectively complete self-contained copies of the project source, together with the ability to merge one branch into another, thereby incorporating the changes into the original branch. The best thing about a branch is that you can make your changes to the project in isolation from the master copy of the code, and then merge your changes in only when they’re done. This is especially helpful when collaborating with other users ; having a separate branch lets you make changes independently from other developers, reducing the risk of accidental conflicts.

->to create a new branch from master branch
to create a branch and check it out at the same time
$git checkout -b <branch name>
or
we can  break this into two steps. As a first step, use git branch to make a branch with the name test-branch. (This involves passing an argument to git branch, as in git branch <branch name>.) Then confirm that the new branch exists but isn’t currently checked out by running git branch without an argument.
$ git branch test-branch

If we check out the master branch and try deleting the test branch using git branch -d 
, it doesn’t work. The reason is that, in contrast to the created branch(using $ git checkout -b <branch name>), the test branch hasn’t been merged into master, and by design -d doesn’t work in this case. Because we don’t actually want its changes, delete the test by using the related -D option, which deletes the branch in question even if its changes are unmerged.
$git checkout master
$git branch -D test-branch

We can view the current branches using the git branch command:
$ git branch
This lists all the branches currently defined on the local machine, with an asterisk * indicating the currently checked-out branch.

Renaming your local branch
->if you are in the same branch
$git branch -m new-name
->if you are not in the same branch
$git branch -m old-name new-name

Pushing changes to the remote
->if the renamed branch is not pushed to the remote then you can push it normally by
$git push origin new-name
->if the renamed branch is already there on the remote (if you push it using the above method, it will create a new branch instead of replacing it) use
$git push origin :old-name new-name

After making changes to, this will be associated to the branch created even if we edit an original document. we first commit those changes
$git commit -m "..." 

Once we’re done making changes and we’re ready to merge a branch back into the master branch, We can get a handle on which changes we’ll be merging in by using git diff;this command can be used by itself to see the difference between unstaged changes and our last commit, but the same command can be used to show diffs between branches. This can take the form git diff branch-1 branch-2, but if you leave the branch unspecified Git automatically diffs against the current branch

To incorporate the changes on created branch into master, the first step is to check out the master branch:
$ git checkout master
Note that, unlike the checkout command when creating a branch, here we omit the -b option because the master branch already exists.

The next step is to merge in the changes on the other branch, which we can do with git merge:
$ git merge created_branch

In the present case, the master branch didn’t change while we were working on created branch, but Git excels even when the original branch has changed in the interim. This situation is especially common when collaborating with others , but can happen even when working alone.
Suppose, for example, that we discovered a typo on master and wanted to fix it and push up immediately. In that case the master branch would change, but we could still merge in the topic branch as usual. There is a possibility that changes on master would conflict with the merged changes, but Git is good at automatically merging content. Even when conflict is unavoidable, Git is good at marking conflicts explicitly so that we can resolve them by hand.

Having merged in the changes, we can sync up the local master branch with the version at GitHub (called origin/master) as usual:

$ git push

Since we probably don’t need the created branch any longer, we can optionally delete it, 
git branch -d <created_branch>

Deleting only in the local
->if you want to delete a branch only in the local and not in the remote you can use this
$git branch -d branch_name 
-or-
$git branch -D branch_name
use -D only If there are un-merged changes which you want to delete.

->Step-2: Deleting only in the remote
You want a branch to present in the local but not in the remote, just do this
$git push origin --delete branch_name

Step-3: Deleting in both local and remote
if this is the case, then
Complete Step-1 and do Step-2 or vice-versa.

Rebasing
The most common way to combine branches is git merge, but there’s a second method called git rebase that you’re likely to encounter at some point. My advice for now is: ignore git rebase. The differences between merging and rebasing are subtle, and conventions for using rebase differ, so I recommend using git rebase only when an advanced Git user tells you to; otherwise, use git merge to combine the contents of two branches.

Recovering from errors
One of the most useful features of Git is its ability to let us recover from errors that would otherwise be catastrophic. The error-recovery techniques themselves can be dangerous, though, so they should always be implemented with care.

1.)if we make an unintentional change to a project and want to get back to the state of the repository as of the most recent commit (a state known as HEAD)
we can undo these unwanted changes by passing the -f (force) option to checkout, which forces Git to check out HEAD
$git checkout -f
The status “working directory clean” indicates that there are no changes, and you can verify by running $cat <file name> that its contents have been restored.
It’s worth noting that git checkout -f itself is potentially dangerous, as it wipes out all the changes you’ve made, so use this trick only when you’re 100% sure you want to revert to HEAD

2.)Another source of robustness against error is using branches, because changes made on one branch are isolated from other branches, you can always just delete the branch if things go horribly wrong as demonstrated by the test branch above

3.)A final example of recovering from error involves the common case of a bug or other defect that makes its way into a project, origins unknown. In such a case, it’s convenient to be able to check out an earlier version of the repository. The way to do this is to use the SHAs from the Git log . For example, to restore a website project to the state right after the second commit, we would run git log and navigate to the beginning of the log. Because git log uses the less interface, we can do this by typing G to go to the last line of the log.
$ git log
commit 03aff34ec4f9690228e057a4252bcca169a868b4
Author: Michael Hartl <michael@michaelhartl.com>
Date:   Mon Dec 21 21:27:56 2015 -0800
Add content to index.html
To check out the commit with the message “Add content to index.html”, simply copy the SHA and check it out:
$ git checkout 03aff34ec4f9690228e057a4252bcca169a868b4
Note: checking out '03aff34ec4f9690228e057a4252bcca169a868b4'.
Note that the branch name in the last line  changes to reflect the value of the SHA, and Git  issues a warning that we are in a ‘detached HEAD’ state. I recommend using this technique to inspect the state of the project and figure out any necessary changes, then check out the master branch to apply them:
$ git checkout master
At this point, you could switch to your text editor and make any necessary changes (such as fixing a bug discovered on the earlier commit).

->The git checkout -f trick works only with files that are staged for commit or are already part of the repository, but sometimes you want to get rid of new files as well.If we were to create a file using touch, then git add it. running git checkout -f gets rid of it.

->Like many other Unix programs, git accepts both “short form” and “long form” options. Repeat the previous exercise with git checkout --force to confirm that the effects of -f and --force are identical. Extra credit: Double-check this conclusion by finding the “force” option in the output of git help checkout.

Senario 2:
Tracking a remote project- in workplace maybe/ making it easier to collaborate with others -gits biggest strength:
This is especially the case when using repository hosts like GitHub or Bitbucket, but it is also possible to host Git repositories on private servers (sometimes using software like GitLab to get many GitHub-like benefits)

First step is to ensure we git push so that all our code is in the remote repository.
Next is to add other party as a collaborator on the website repository, which we could do at GitHub by clicking on Settings > Collaborators and then put other party’s GitHub username in the Add collaborator box
After adding other party's username they recieve a notification, go to github and geth the clone URL which lets them make a full copy of the repository (including its history) using git clone

-Cloning a remote Repo:
$ git clone <url> <where to clone>(syntax) 
E.g$ git clone https://gothic.com/coreyMShafer/remote_repo.git . The dot here at the end means(stands for) the current directory

$ git clone <clone URL> website-copy 
the argument website-copy to git clone, thereby showing how to use a different name than the original repo, but usually you just run git clone <clone URL>, which uses the default repo name 

after the other  user makes changes to the repo, he commits the changes and pushes to the remote repo. we then use git pull to sync our local repo with the remote
$git pull origin master-pulls any changes that have been made since the last time that we pulled from that repo.
Without changes it will show u: Already up-to-date

when two collaborators edit the same file, it is possible that the changes might be irreconcilable. Git is pretty smart about merging in changes, and in general conflicts are surprisingly rare, but it’s important to be able to handle them when they occur.
->if one collaborator pushes changes to a repo, the other has to first pull the repo before he/she can push changes she has made.
$ git pull
Even though one user made changes to a file, there is no conflict because Git figures out how to combine the diffs. In particular, git pull brings in the changes from the remote repo and uses merge to combine them automatically, adding the option to add a commit message by dropping the other user into the default editor, which on most systems is Vim. We quit vim by :q.
We can confirm that this worked by checking the log, which shows both the merge commit and one users commit from the original copy
if other user pushes it should got through.

Viewing info about the Remote Repository:
$ git remote -v -Lists info to the repo. Location on local machine of where the repo is

$ git branch -a- lists all branches of the repo. Not only locally but remotely as well.

Once we make changes to a file
$git diff -shows changes that I have made to the code.
-(minus sign)Reps what is removed
+(plus sign) Reps what has been added in(the change)
Run $git status....In working station it will show modified.<file>
Run $git add-A
Adds the changes
$git status shows the changes
$git commit -m "changes titles e.g. Multiply Function"
All the above changes have been made locally. 

To push these changes to the remote repo to give other people access to them:
$git pull origin master
$git push origin master

.
.git push origin master 
(Origin refers to the name of the remote
repo while master refers to the branch we want to push to)

Common Workflow when using git.
Create a branch for desired feature syntax for creating a branch is 
$ git branch <name of branch>
e.g. $git branch calc-divide
Running $git branch 
It returns all branches. The one with an asterisk * is the one currently being worked on . To start working on another , we have to run $git checkout <name of branch we want>
e.g $git checkout calc-divide
Running $git branch again will show that the current in use is calc divide.
Run $git status
$git add -A to add changes to staging area
$git commit -m "Divide Function"
This only changes the local calc-divide branch and has no effect on remote Repo.
-After Commit Push Branch To Remote
$git push -u <name of remote repo> <branch we want to push to>
$git push -u origin calc-divide
The u option tells git that we want to associate our local calc-divide branch with our remote calc divide branch and then in the future instead of $git push -u origin calc-divide, we can just do 
git pull
git push 
and automatically knows that these branches are associated with each other.
$git branch -a
shows two branches
*calc-divide 
master

Pushing a branch up to the remote repo;
This is where most unit tests are run to make sure that all the code runs well before it's merged with master.. If everything runs well and we want to merge with master
$git checkout master
$git pull origin master
$git branch --merged -Tells us branches we have merged. To merge syntax; 
$git merge <branch we want to merge> e.g.
$git merge calc-divide
$git push origin master push to remote master branch

Deleting a branch
Rerun $git branch --merged
Delete locally $git branch -d calc divide
Delete from local repo:
$git push origin --delete <name of branch>
e.g. $git push origin --delete calc-divide

Git-Learn enough
Real artists ship.-Finish and get it out to the world.




